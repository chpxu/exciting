"""
Procedures for testing
"""

import os
import shutil
import xml.etree.ElementTree as ET 
from subprocess import PIPE, Popen, TimeoutExpired
import time
import warnings

from .parsers import ErroneousFileError, parseInit, getInitFile, parser_chooser
from .tester.test import fromInit
from .tester.report import Report, indent, test_suite_summary, skipped_test_summary, timing_summary
from .tester.failure import *


def collectSingleReport(testFarm: str, testDir: str, root):
    """
    Collects content from report.xml for a single test case.
    Input:
        testFarm        string              location of the test farm
        testDir         string              test case for that report.xml will be collected
        root            ET root element     root element for reports.xml in report/
    """
    try:
        rootT = ET.parse(os.path.join(testFarm, testDir, 'report.xml')).getroot()
        root.insert(1, rootT)
        return
    except FileNotFoundError:
        return


def collectReports(testFarm:str, testList:list):
    """
    Collects content from report.xml for test cases in test list (see collectSingleReport)
    Input:
    :testFarm:    location of the test farm
    :testList:    test cases for that report.xml will be collected
    """
    root = ET.Element("reports")
    for testDir in testList:
        collectSingleReport(testFarm, testDir, root)
    indent(root)
    tree = ET.ElementTree(root)
    tree.write('report/reports.xml')

    os.system('xsltproc report/reports2html.xsl report/reports.xml > report/report.html')


def exciting_run(executable:str, mainOut:str, maxTime:int):
    """
    Executes a exciting run, checks if it was successfull.
    Input:
        executable  string    executable command (poorly-named). For example:
                              exciting_serial exciting_smp or mpirun -np NP exciting_mpismp
        mainOut     string    main output file (INFO.OUT)
        maxTime     int       maximum time for an exciting run in seconds
    Output:
        success     bool                true if run was successfull, false else
        errMess     list of strings     terminal output of exciting
        run_time    float     Run time of job 
    """
    t_start = time.time()
    exciting_run = Popen(executable.split(), stdout = PIPE)
    
    try:
        errMess = exciting_run.communicate(timeout=maxTime)[0]
        runSucc = os.path.isfile(mainOut)
    except TimeoutExpired:
        exciting_run.kill()
        errMess = 'Time expired.'
        runSucc = False
    
    exciting_run.wait()
    t_end = time.time()
    
    return runSucc, errMess, t_end-t_start


def runSingleTest(testFarm:str, mainOut:str, testDir:str, runDir:str,
                  refDir:str, init_default:str, executable:str, maxTime:str, 
                  timing:dict, handle_errors:bool):
    """
    Runs a singel test.
    :testFarm:        location of the test farm
    :mainOut:         main output file of the exciting calculation
    :testDir:         test case that will be ran
    :runDir:          name of the run directory of the test case
    :refDir:          name of the ref directory of the test case
    :init_default:    location of the default init.xml
    :execuatable:     executable command 
    :timing:          test run times in seconds
    :handle_errors:   Whether or not failures and passes are allowed to propagate

    Output:
        report          object      report instance of the test     
    """
    print('Run test %s:'%testDir)
    os.chdir(os.path.join(testFarm,testDir))
    try:
        init = parseInit(getInitFile(testDir))
    except FileNotFoundError:
        init = parseInit(os.path.join('../..', init_default))
    except OSError:
        os.chdir('../../')
        return

    name = init['name']
    description = init['description']
    tests = init['tests']

    # Initialize report object:
    report = Report(name, description)

    if not os.path.isdir(runDir):
        # TODO(Alex) Issue #48. run should be generated by the test suite and not carried
        # in the file system. It's unnecessary and (in conjunction with exciting file names) makes
        # it impossible to write generic .gitignore patterns. 
        warnings.warn("run directory cannot be found. Please ensure that it is added to version control. \n "
                    + ".gitignore patterns mean that it will no show up with 'git status'")
        
    # The actual test run is performed. If the run fails, then an error message is added
    # and all other tests are skipped.
    os.chdir(runDir)
    runSuc, errMess, timing[name] = exciting_run(executable, mainOut, maxTime)
    
    if runSuc==False:
        report.runFailed(testDir, errMess)
        os.chdir('../')
    else:
        print('Run succeeded')
        os.chdir('../')

        # test all the files specified in init.xml:

        #TODO(Alex/Bene/Hannah) Issue 67 This needs simplifying
        for testInit in tests:
            testFile = testInit['file']
            runPath = os.path.join(runDir, testFile)
            # Handles the case, if files are saved in the run directory or in a sub directory of the run directory
            if len(os.path.split(testFile)[0])>0:
                testDirSub = os.path.split(testFile)[0]
                testFile = os.path.split(testFile)[1]
                refDirSub = os.path.join(refDir, '%s_REF'%testDirSub)
                refPath = os.path.join(refDirSub, '%s.ref'%testFile)
            else:
                refPath = os.path.join(refDir, '%s.ref'%testFile)

            test = fromInit(testInit)
            # Check if reference file exists
            if not os.path.isfile(refPath):
                test.append(Failure(Failure_code.REFERENCE, err_msg=testInit['file']))           
                report.collectTest(test)
                continue
            # Checks if the file exists and is not broken
            try:
                runData = parser_chooser(runPath)
            except OSError:
                test.append(Failure(Failure_code.FILENOTEXIST, err_msg=testInit['file']))
                report.collectTest(test)
                continue
            except ErroneousFileError:
                test.append(Failure(Failure_code.ERRORFILE, err_msg=testInit['file']))
                report.collectTest(test)
                continue

            if '_REF' in refPath:
                os.rename(refPath, os.path.join(refDirSub, testFile))
                refPath = os.path.join(refDirSub, testFile)
                refData = parser_chooser(refPath)
                os.rename(refPath, os.path.join(refDirSub, '%s.ref'%testFile))
            else:
                os.rename(refPath, os.path.join(refDir, testFile))
                refPath = os.path.join(refDir, testFile)
                refData = parser_chooser(refPath)
                os.rename(refPath, os.path.join(refDir, '%s.ref'%testFile))

            if 'info.xml' in testFile:
                test.evaluate_info(runData, refData)
            elif 'INFO.OUT' in testFile and 'WANNIER' not in testFile:
                test.evaluate_INFO(runData, refData)
            elif 'eigval.xml' in testFile:
                test.evaluate_eigval(runData, refData)
            else:                                                                               
                test.evaluate(runData, refData)

            report.collectTest(test)

    print('Time (s): %.1f' % timing[name])
    report.writeToTerminal()
    report.writeToXML(testDir)
    report.assert_errors(handle_errors)

    os.chdir('../../')
    return report 


def runTests(testFarm:str, mainOut:str, testList:list, runDir:str, refDir:str,
             init_default:str, executable:str, np:int, omp:int, maxTime:int,
             skipped_tests:list, handle_errors:bool):
    """
    Runs tests in testList (see runSingleTest).
    :testFarm:          location of the test farm
    :mainOut:           main output file of the exciting calculation
    :testList:          list of string      test cases that will be ran
    :runDir:            name of the run directory of the test case
    :refDir:            name of the ref directory of the test case
    :init_default:      location of the default init.xml
    :executable:        executable command for the exciting run
    :np:                number of MPI processes
    :omp:               number of OMP threads
    :maxTime:           max time before a job is killed
    :skipped_tests:     list of tests to skip
    :handle_errors:     Whether or not failures and passes are allowed to propagate
    """
    if 'exciting_serial' in executable:
        print('Run tests with exciting_serial.')
    elif 'exciting_smp' in executable:
        print('Run tests with exciting_smp with %i open MP threads.'%(omp))
    elif 'exciting_mpismp' in executable:
        print('Run tests with exciting_mpismp with %i open MP threads and %i MPI processes.'%(omp, np))
    elif 'exciting_purempi' in executable:
        print('Run tests with exciting_purempi %i MPI processes.'%np)

    testList = remove_tests_to_skip(testList, skipped_tests)
    timing = {}
    test_suite_report = []
    
    for testDir in testList:
        test_suite_report.append(
            runSingleTest(testFarm, 
                          mainOut, 
                          testDir, 
                          runDir, 
                          refDir, 
                          init_default, 
                          executable, 
                          maxTime, 
                          timing,
                          handle_errors)
                                )

    all_asserts_succeeded = test_suite_summary(test_suite_report)
    skipped_test_summary(skipped_tests)
    timing_summary(timing, verbose=True)
    assert all_asserts_succeeded, "Some test suite assertions failed or were passed over"

    return 
        

def isNotForbiddenFile(f:str, forbiddenFiles:list):
    """
    Returns True if a file is not in forbidden files.
    Input:
        f               string          file name
        forbiddenFiles  list of string  list of forbidden files
    Output:
        out             bool
    """
    out = True
    for fF in forbiddenFiles:
        out = out and (fF not in f)
    return out


def runSingleReference(testFarm:list, mainOut:str, testDir:str, refDir:str, executable:str, forbiddenFiles:list, maxTime:int):
    """
    Reference run for single test case.
    :testFarm:          location of the test farm
    :mainOut:           main output file of the exciting calculation
    :testDir:           test case for that the reference will be calculated
    :refDir:            name of the ref directory of the test case
    :execuatable:       executable for the exciting run
    :forbiddenFiles:    files that will not be saved as reference
    """
    os.chdir(os.path.join(testFarm,testDir,refDir))

    dirs, files = next(os.walk('.'))[1:]
    for f in files:
        if '.ref' in f:
            os.remove(f)
    for d in dirs:
        if '_REF' in d:
            shutil.rmtree(d)
    runSuc, errMess, timing = exciting_run(executable, mainOut, maxTime)
    dirs, files = next(os.walk('.'))[1:]
    if runSuc:
        for f in files:
            if f not in forbiddenFiles and 'OCCSV' not in f and 'EVEC' not in f and 'EVALFV' and f not in 'EVALSV':
                os.rename(f, '%s.ref'%f)
        for d in dirs:
            if isNotForbiddenFile(f, forbiddenFiles):
                os.chdir(d)
                files = next(os.walk('.'))[-1]
                for f in files:
                    if isNotForbiddenFile(f, forbiddenFiles):
                        os.rename(f, '%s.ref'%f)
                os.chdir('..')
                os.rename(d, '%s_REF'%d)
                
        print('%s: Run succeeded'%testDir)
    else:
        print('%s: Run failed'%testDir)
        for err in errMess:
            print(err)
    print('Time (s): %.1f' % timing)
    os.chdir('../../..')


def runReferences(testFarm:str, mainOut:str, testList:list, refDir:str, executable:str, forbiddenFiles:list, maxTime:int):
    """
    Reference run for all tests (see runSingleReference).
    :testFarm:          location of the test farm
    :mainOut:           main output file of the exciting calculation
    :testList:          list of test cases for that the reference will be calculated
    :testDir:           test case for that the reference will be calculated
    :refDir:            name of the ref directory of the test case
    :execuatable:       executable for the exciting run
    :forbiddenFiles:    files that will not be saved as reference
    """
    for testDir in testList:
        runSingleReference(testFarm, mainOut, testDir, refDir, executable, forbiddenFiles, maxTime)


def cleanSingleTest(testFarm:str, testDir:str, runDir:str, refDir:str, forbiddenFiles:str):
    """
    Removes all files from exciting calculation in a single test case except files stored as reference and files defined in forbiddenFiles.
    :testFarm:          location of the test farm
    :testDir:           test case that will be cleaned
    :runDir:            name of the run directory of the test case
    :refDir:            name of the ref directory of the test case
    :forbiddenFiles:    files that will not be removed
    """
    os.chdir(os.path.join(testFarm, testDir, runDir))
    dirs, files = next(os.walk('.'))[1:]
    for f in files:
        if f not in forbiddenFiles:
            os.remove(f)
    for d in dirs:
        if f not in forbiddenFiles:
            shutil.rmtree(d)
    os.chdir(os.path.join('..', refDir))
    dirs, files = next(os.walk('.'))[1:]
    for f in files:
        if f not in forbiddenFiles and '.ref' not in f:
            os.remove(f)
    for d in dirs:
        if f not in forbiddenFiles and '_REF' not in d:
            shutil.rmtree(d)
    os.chdir('../../..')


def cleanTests(testFarm:str, testList:list, runDir:str, refDir:str, forbiddenFiles:str):
    """
    Cleans the tests in testList (see cleanSingleTest).
    :testFarm:          location of the test farm
    :testList:          test cases that will be cleaned
    :testDir:           test case that will be cleaned
    :runDir:            name of the run directory of the test case
    :refDir:            name of the ref directory of the test case
    :forbiddenFiles:    files that will not be removed
    """
    print('Clean test directories.')
    
    for testDir in testList:
        cleanSingleTest(testFarm, testDir, runDir, refDir, forbiddenFiles)


def newTest_dir(testFarm:str, name:str, runDir:str, refDir:str):
    """
    Creates new test case at location path.
    Input:
    :testFarm:    location of the test farm
    :name:        name of the new test case
    :runDir:      name of the run directory of the test case
    :refDir:      name of the ref directory of the test case
    """
    path = os.path.join(testFarm, name)
    os.makedirs(path)
    os.makedirs(os.path.join(path, runDir))
    os.makedirs(os.path.join(path, refDir))


def copyInputFiles(src:str, testFarm:str, name:str, runDir:str, refDir:str, inputInd:str, species:list):
    """
    Copies input.xml and species files from a reference exciting calculation to a test case, located at path.
    :src:         source of the reference calculation
    :testFarm:    location of the test farm
    :name:        name of the new test case
    :refDir:      name of the ref directory of the test case
    :inputInd:    indicator of the input file. In case of input.xml, "input" will work.
    :species:     list od strings list of possible species files
    """
    files_src = next(os.walk(src))[2]
    files_copy = []
    for f in files_src:
        if inputInd in f:
            files_copy.append(f)
        elif f in species:
            files_copy.append(f)
        else:
            pass
    path = os.path.join(testFarm, name)
    for f in files_copy:
        shutil.copy(os.path.join(src,f), os.path.join(path,runDir,f))
        shutil.copy(os.path.join(src,f), os.path.join(path,refDir,f))


def create_init(testFarm:str, name:str, description:str, init:str):
    """
    Copies init_default.xml from xml/init_templates to the directory of the new test case.
    :testFarm:     location of the test farm   
    :name:         name of the new test case
    :description:  description in the init file
    :init:         init file template
    """
    shutil.copy(os.path.join("xml/init_templates", init), os.path.join(testFarm, name, "init.xml"))
    with open(os.path.join(testFarm, name, "init.xml"), 'r') as file :
        lines = file.read()
    lines = lines.replace('test_name', name)
    lines = lines.replace('test_description', description)
    file.close
    with open(os.path.join(testFarm, name, "init.xml"), 'w') as file :
        file.write(lines)
    file.close


def remove_tests_to_skip(all_tests:list, skipped_tests:list) -> list:
    """
    Remove tests given in 'skipped_tests' from the test suite,
    for a specific executable choice. 

    This is useful if a particular test crashes or hangs, and needs to be
    debugged BUT shouldn't cause the test suite to report a failure.

    :param all_tests:     list of all test names
    :param skipped_tests: list of tests to skip. Each entry is a dict

    :return tests_to_run: list of tests to run (with skipped_tests removed) 
    """

    tests_to_skip = [test['name'] for test in skipped_tests]    
    # Using sets is probably faster but they won't preserve ordering. Could use ordered sets
    tests_to_run = []
    for test in all_tests:
        if test not in tests_to_skip:
            tests_to_run.append(test)
    
    return tests_to_run
