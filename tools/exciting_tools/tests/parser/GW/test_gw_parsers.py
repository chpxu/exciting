""" Test all GW output file parsers, except GW_INFO.OUT
"""
import pathlib
import pytest
import numpy as np

from excitingtools.utils import get_new_line_indices

from excitingtools.parser.gw_parser import k_points_from_evalqp, \
    n_states_from_evalqp, parse_evalqp, parse_vxcnn, vkl_from_vxc, parse_eps00_frequencies, \
    parse_eps00_gw


class MockFile:
    def __init__(self, file: pathlib.Path, string: str):
        # File object
        self.file = file
        # File contents
        self.string = string
        # Name prepended by path
        self.full_path = self.file.as_posix()


@pytest.fixture
def evalqp_mock(tmp_path):
    """ Mock EVALQP.OUT data with energies for 3 k-points
    """
    evalqp_str = """k-point #     1:    0.000000    0.000000    0.000000    0.125000
     state   E_KS       E_HF       E_GW       Sx         Re(Sc)     Im(Sc)     Vxc        DE_HF      DE_GW      Znk
       1   -14.68627  -16.50308  -16.31014   -4.72516    0.17351    0.00002   -2.90835   -1.81681   -1.62387    0.98817
       2   -11.48914  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
       3   -11.48914  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
       4   -11.48914  -12.99338  -12.79203   -4.36834    0.18151    0.00003   -2.86410   -1.50424   -1.30289    0.98500
       5    -6.24399   -7.20716   -7.01655   -3.72742    0.17144    0.00000   -2.76425   -0.96317   -0.77257    0.97579
       6    -6.24399   -7.20716   -7.01652   -3.72742    0.17144   -0.00001   -2.76425   -0.96317   -0.77253    0.97575
       7    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594
       8    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594
       9    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594
      10    -1.82156   -2.31023   -2.07248   -1.52298    0.20180    0.00623   -1.03431   -0.48867   -0.25092    0.87468
      11    -1.00771   -1.29282   -1.07701   -1.21488    0.19790    0.02221   -0.92977   -0.28511   -0.06930    0.79459

    k-point #     2:    0.000000    0.000000    0.500000    0.500000
     state   E_KS       E_HF       E_GW       Sx         Re(Sc)     Im(Sc)     Vxc        DE_HF      DE_GW      Znk
       1   -14.68627  -16.50308  -16.31014   -4.72516    0.17351    0.00002   -2.90835   -1.81681   -1.62387    0.98817
       2   -11.48915  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30289    0.98500
       3   -11.48915  -12.99338  -12.79204   -4.36834    0.18151    0.00003   -2.86410   -1.50424   -1.30289    0.98500
       4   -11.48914  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
       5    -6.24401   -7.20719   -7.01653   -3.72740    0.17145   -0.00001   -2.76423   -0.96318   -0.77252    0.97574
       6    -6.24401   -7.20719   -7.01650   -3.72740    0.17145   -0.00001   -2.76423   -0.96318   -0.77249    0.97570
       7    -6.24345   -7.20933   -7.01756   -3.73065    0.17268    0.00003   -2.76477   -0.96588   -0.77411    0.97593
       8    -6.24344   -7.20932   -7.01754   -3.73066    0.17268    0.00003   -2.76478   -0.96588   -0.77410    0.97593
       9    -6.24344   -7.20932   -7.01755   -3.73066    0.17268    0.00003   -2.76478   -0.96588   -0.77411    0.97593
      10    -1.81969   -2.30723   -2.07258   -1.52476    0.20051    0.00867   -1.03723   -0.48754   -0.25289    0.88104
      11    -1.03473   -1.34882   -1.09998   -1.20344    0.22865    0.02686   -0.88936   -0.31408   -0.06525    0.76380

    k-point #     3:    0.000000    0.500000    0.500000    0.375000
     state   E_KS       E_HF       E_GW       Sx         Re(Sc)     Im(Sc)     Vxc        DE_HF      DE_GW      Znk
       1   -14.68627  -16.50308  -16.31014   -4.72516    0.17351    0.00002   -2.90835   -1.81681   -1.62387    0.98818
       2   -11.48915  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
       3   -11.48915  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30289    0.98500
       4   -11.48915  -12.99338  -12.79204   -4.36834    0.18151    0.00003   -2.86410   -1.50424   -1.30289    0.98500
       5    -6.24405   -7.20722   -7.01657   -3.72737    0.17144   -0.00001   -2.76420   -0.96317   -0.77252    0.97574
       6    -6.24403   -7.20721   -7.01657   -3.72738    0.17144   -0.00000   -2.76421   -0.96317   -0.77253    0.97575
       7    -6.24346   -7.20934   -7.01757   -3.73064    0.17268    0.00004   -2.76476   -0.96588   -0.77411    0.97593
       8    -6.24344   -7.20932   -7.01755   -3.73066    0.17268    0.00003   -2.76478   -0.96588   -0.77412    0.97594
       9    -6.24344   -7.20932   -7.01755   -3.73066    0.17268    0.00003   -2.76478   -0.96588   -0.77411    0.97593
      10    -1.81908   -2.30620   -2.07323   -1.52531    0.19899    0.00760   -1.03818   -0.48712   -0.25415    0.88205
      11    -1.03685   -1.35370   -1.10126   -1.20433    0.23184    0.02427   -0.88748   -0.31684   -0.06441    0.75775

      """

    evalqp_file = tmp_path / "EVALQP.DAT"
    evalqp_file.write_text(evalqp_str)

    return MockFile(evalqp_file, evalqp_str)


def test_k_points_from_evalqp(evalqp_mock):
    """ Test parsing of EVALQP.DAT
    """
    ref = {
        1: {'k_point': [0.000000, 0.000000, 0.000000], 'weight': 0.125000},
        2: {'k_point': [0.000000, 0.000000, 0.500000], 'weight': 0.500000},
        3: {'k_point': [0.000000, 0.500000, 0.500000], 'weight': 0.375000}
    }

    k_points_and_weights = k_points_from_evalqp(evalqp_mock.full_path)

    assert k_points_and_weights == ref, "k_points_and_weights should match reference"


def test_n_states_from_evalqp(evalqp_mock):
    """ Test parsing of EVALQP.DAT
    """
    assert n_states_from_evalqp(evalqp_mock.string) == 11, "Final k-point in string should have 11 states"

    evalqp_str_with_one_kpoint = """k-point #     1:    0.000000    0.000000    0.000000    0.125000
 state   E_KS       E_HF       E_GW       Sx         Re(Sc)     Im(Sc)     Vxc        DE_HF      DE_GW      Znk
   1   -14.68627  -16.50308  -16.31014   -4.72516    0.17351    0.00002   -2.90835   -1.81681   -1.62387    0.98817
   2   -11.48914  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
   3   -11.48914  -12.99338  -12.79204   -4.36834    0.18150    0.00003   -2.86410   -1.50424   -1.30290    0.98500
   4   -11.48914  -12.99338  -12.79203   -4.36834    0.18151    0.00003   -2.86410   -1.50424   -1.30289    0.98500
   5    -6.24399   -7.20716   -7.01655   -3.72742    0.17144    0.00000   -2.76425   -0.96317   -0.77257    0.97579
   6    -6.24399   -7.20716   -7.01652   -3.72742    0.17144   -0.00001   -2.76425   -0.96317   -0.77253    0.97575
   7    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594
   8    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594
   9    -6.24340   -7.20928   -7.01752   -3.73069    0.17268    0.00003   -2.76481   -0.96588   -0.77412    0.97594

  """

    assert n_states_from_evalqp(evalqp_str_with_one_kpoint) == 9, "k-point 1 should have 9 states"


def test_parse_evalqp(evalqp_mock):
    """ Test parsing eigenvalues and weights from EVALQP.DAT.
    """

    # Energies for all states, per k-point
    energies_1 = np.array(
        [[-14.68627, -16.50308, -16.31014, -4.72516, 0.17351, 0.00002, -2.90835, -1.81681, -1.62387, 0.98817],
         [-11.48914, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30290, 0.98500],
         [-11.48914, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30290, 0.98500],
         [-11.48914, -12.99338, -12.79203, -4.36834, 0.18151, 0.00003, -2.86410, -1.50424, -1.30289, 0.98500],
         [-6.24399, -7.20716, -7.01655, -3.72742, 0.17144, 0.00000, -2.76425, -0.96317, -0.77257, 0.97579],
         [-6.24399, -7.20716, -7.01652, -3.72742, 0.17144, -0.00001, -2.76425, -0.96317, -0.77253, 0.97575],
         [-6.24340, -7.20928, -7.01752, -3.73069, 0.17268, 0.00003, -2.76481, -0.96588, -0.77412, 0.97594],
         [-6.24340, -7.20928, -7.01752, -3.73069, 0.17268, 0.00003, -2.76481, -0.96588, -0.77412, 0.97594],
         [-6.24340, -7.20928, -7.01752, -3.73069, 0.17268, 0.00003, -2.76481, -0.96588, -0.77412, 0.97594],
         [-1.82156, -2.31023, -2.07248, -1.52298, 0.20180, 0.00623, -1.03431, -0.48867, -0.25092, 0.87468],
         [-1.00771, -1.29282, -1.07701, -1.21488, 0.19790, 0.02221, -0.92977, -0.28511, -0.06930, 0.79459]]
        )

    energies_2 = np.array(
        [[-14.68627, -16.50308, -16.31014, -4.72516, 0.17351, 0.00002, -2.90835, -1.81681, -1.62387, 0.98817],
         [-11.48915, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30289, 0.98500],
         [-11.48915, -12.99338, -12.79204, -4.36834, 0.18151, 0.00003, -2.86410, -1.50424, -1.30289, 0.98500],
         [-11.48914, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30290, 0.98500],
         [-6.24401, -7.20719, -7.01653, -3.72740, 0.17145, -0.00001, -2.76423, -0.96318, -0.77252, 0.97574],
         [-6.24401, -7.20719, -7.01650, -3.72740, 0.17145, -0.00001, -2.76423, -0.96318, -0.77249, 0.97570],
         [-6.24345, -7.20933, -7.01756, -3.73065, 0.17268, 0.00003, -2.76477, -0.96588, -0.77411, 0.97593],
         [-6.24344, -7.20932, -7.01754, -3.73066, 0.17268, 0.00003, -2.76478, -0.96588, -0.77410, 0.97593],
         [-6.24344, -7.20932, -7.01755, -3.73066, 0.17268, 0.00003, -2.76478, -0.96588, -0.77411, 0.97593],
         [-1.81969, -2.30723, -2.07258, -1.52476, 0.20051, 0.00867, -1.03723, -0.48754, -0.25289, 0.88104],
         [-1.03473, -1.34882, -1.09998, -1.20344, 0.22865, 0.02686, -0.88936, -0.31408, -0.06525, 0.76380]]
    )

    energies_3 = np.array(
        [[-14.68627, -16.50308, -16.31014, -4.72516, 0.17351, 0.00002, -2.90835, -1.81681, -1.62387, 0.98818],
         [-11.48915, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30290, 0.98500],
         [-11.48915, -12.99338, -12.79204, -4.36834, 0.18150, 0.00003, -2.86410, -1.50424, -1.30289, 0.98500],
         [-11.48915, -12.99338, -12.79204, -4.36834, 0.18151, 0.00003, -2.86410, -1.50424, -1.30289, 0.98500],
         [-6.24405, -7.20722, -7.01657, -3.72737, 0.17144, -0.00001, -2.76420, -0.96317, -0.77252, 0.97574],
         [-6.24403, -7.20721, -7.01657, -3.72738, 0.17144, -0.00000, -2.76421, -0.96317, -0.77253, 0.97575],
         [-6.24346, -7.20934, -7.01757, -3.73064, 0.17268, 0.00004, -2.76476, -0.96588, -0.77411, 0.97593],
         [-6.24344, -7.20932, -7.01755, -3.73066, 0.17268, 0.00003, -2.76478, -0.96588, -0.77412, 0.97594],
         [-6.24344, -7.20932, -7.01755, -3.73066, 0.17268, 0.00003, -2.76478, -0.96588, -0.77411, 0.97593],
         [-1.81908, -2.30620, -2.07323, -1.52531, 0.19899, 0.00760, -1.03818, -0.48712, -0.25415, 0.88205],
         [-1.03685, -1.35370, -1.10126, -1.20433, 0.23184, 0.02427, -0.88748, -0.31684, -0.06441, 0.75775]]
    )

    ref = {
        1: {'k_point': [0.000000, 0.000000, 0.000000], 'weight': 0.125000},
        2: {'k_point': [0.000000, 0.000000, 0.500000], 'weight': 0.500000},
        3: {'k_point': [0.000000, 0.500000, 0.500000], 'weight': 0.375000}
        }

    output = parse_evalqp(evalqp_mock.full_path)

    # k-points
    assert len(output) == 3, "Expect 3 k-points"
    assert min([ik for ik in output.keys()]) == 1, 'k-point indexing starts at 1'
    assert output[1]['k_point'] == ref[1]['k_point'], "Compare k-point 1 to reference"
    assert output[2]['k_point'] == ref[2]['k_point'], "Compare k-point 2 to reference"
    assert output[3]['k_point'] == ref[3]['k_point'], "Compare k-point 3 to reference"

    # Weights
    assert output[1]['weight'] == ref[1]['weight'], "Compare weight 1 to reference"
    assert output[2]['weight'] == ref[2]['weight'], "Compare weight 2 to reference"
    assert output[3]['weight'] == ref[3]['weight'], "Compare weight 3 to reference"

    # Energies
    assert output[1]['energies'].shape == (11, 10), 'rows = 11 states and cols = 10 energies'
    assert np.allclose(output[1]['energies'], energies_1), "Compare energies 1 to reference"
    assert np.allclose(output[2]['energies'], energies_2), "Compare energies 2 to reference"
    assert np.allclose(output[3]['energies'], energies_3), "Compare energies 3 to reference"



@pytest.fixture
def vxc__mock(tmp_path):
    """ Mock VXCNN.DAT data with energies for 3 k-points
    """
    vxc_string = """ik=   1    vkl=  0.0000  0.0000  0.0000
       1       -2.908349       -0.000000
       2       -2.864103        0.000000
       3       -2.864103       -0.000000
       4       -2.864103       -0.000000
       5       -2.764246       -0.000000
       6       -2.764246        0.000000
       7       -2.764809       -0.000000
       8       -2.764809       -0.000000
       9       -2.764809       -0.000000
      10       -1.034312       -0.000000
      11       -0.929773       -0.000000

    ik=   2    vkl=  0.0000  0.0000  0.5000
     1       -2.908349        0.000000
     2       -2.864100       -0.000000
     3       -2.864100        0.000000
     4       -2.864101       -0.000000
     5       -2.764227       -0.000000
     6       -2.764227        0.000000
     7       -2.764770        0.000000
     8       -2.764777        0.000000
     9       -2.764777        0.000000
    10       -1.037228       -0.000000
    11       -0.889360        0.000000

    ik=   3    vkl=  0.0000  0.5000  0.5000
       1       -2.908349       -0.000000
       2       -2.864099       -0.000000
       3       -2.864099       -0.000000
       4       -2.864099        0.000000
       5       -2.764195        0.000000
       6       -2.764208        0.000000
       7       -2.764760       -0.000000
       8       -2.764780       -0.000000
       9       -2.764780       -0.000000
      10       -1.038185        0.000000
      11       -0.887485       -0.000000
    """
    file = tmp_path / "VXCNN.DAT"
    file.write_text(vxc_string)
    return MockFile(file, vxc_string)


def test_vkl_from_vxc(vxc__mock):
    # k-points in units of the lattice vectors
    vkl_ref = {
        1: [0.0000, 0.0000, 0.0000], 2: [0.0000, 0.0000, 0.5000], 3: [0.0000, 0.5000, 0.5000]
        }
    output = vkl_from_vxc(vxc__mock.full_path)
    assert len(output) == 3, "Expect 3 k-points"
    assert output == vkl_ref, "vkl values equal to vkl_ref"


def test_parse_vxcnn(vxc__mock):

    # Reference V_xc extracted from vxc_string, defined above
    v_xc_1 = np.array([[-2.908349, -0.000000], [-2.864103, 0.000000], [-2.864103, -0.000000],
                       [-2.864103, -0.000000], [-2.764246, -0.000000], [-2.764246, 0.000000],
                       [-2.764809, -0.000000], [-2.764809, -0.000000], [-2.764809, -0.000000],
                       [-1.034312, -0.000000], [-0.929773, -0.000000]])

    v_xc_2 = np.array([[-2.908349, 0.000000], [-2.864100, -0.000000], [-2.864100, 0.000000],
                       [-2.864101, -0.000000], [-2.764227, -0.000000], [-2.764227, 0.000000],
                       [-2.764770, 0.000000], [-2.764777, 0.000000], [-2.764777, 0.000000],
                       [-1.037228, -0.000000], [-0.889360, 0.000000]])

    v_xc_3 = np.array([[-2.908349, -0.000000], [-2.864099, -0.000000], [-2.864099, -0.000000],
                       [-2.864099, 0.000000], [-2.764195, 0.000000], [-2.764208, 0.000000],
                       [-2.764760, -0.000000], [-2.764780, -0.000000], [-2.764780, -0.000000],
                       [-1.038185, 0.000000], [-0.887485, -0.000000]])

    output = parse_vxcnn(vxc__mock.full_path)

    assert [key for key in output[1].keys()] == ['vkl', 'v_xc_nn'], "Key consistency for ik=1 of parsed vxcnn"
    assert [key for key in output[2].keys()] == ['vkl', 'v_xc_nn'], "Key consistency for ik=2 of parsed vxcnn"
    assert [key for key in output[3].keys()] == ['vkl', 'v_xc_nn'], "Key consistency for ik=3 of parsed vxcnn"

    assert output[1]['vkl'] == [0.0000, 0.0000, 0.0000], "vkl (ik=1)"
    assert output[2]['vkl'] == [0.0000, 0.0000, 0.5000], "vkl (ik=2)"
    assert output[3]['vkl'] == [0.0000, 0.5000, 0.5000], "vkl (ik=3)"

    assert output[1]['v_xc_nn'].shape == (11, 2), "Expect V_xc to have 2 cols for 11 states"
    assert output[2]['v_xc_nn'].shape == (11, 2), "Expect V_xc to have 2 cols for 11 states"
    assert output[3]['v_xc_nn'].shape == (11, 2), "Expect V_xc to have 2 cols for 11 states"

    assert np.allclose(output[1]['v_xc_nn'], v_xc_1), "v_xc_nn for ik=1"
    assert np.allclose(output[2]['v_xc_nn'], v_xc_2), "v_xc_nn for ik=2"
    assert np.allclose(output[3]['v_xc_nn'], v_xc_3), "v_xc_nn for ik=3"


# EPS00_GW.OUT segment. Note that first line of file must be blank.
eps_string = """
 (dielectric tensor, random phase approximation)

 frequency index and value:      1    0.00529953
 real part, imaginary part below
    8.31881773    0.00000000    0.00000000         0.00000000    0.00000000    0.00000000
    0.00000000    8.31881773    0.00000000         0.00000000    0.00000000    0.00000000
    0.00000000    0.00000000    8.31881773         0.00000000    0.00000000    0.00000000

 frequency index and value:      2    0.02771249
 real part, imaginary part below
    8.22189228    0.00000000    0.00000000        -0.00000000    0.00000000    0.00000000
    0.00000000    8.22189228    0.00000000         0.00000000   -0.00000000    0.00000000
    0.00000000    0.00000000    8.22189228         0.00000000    0.00000000   -0.00000000

 frequency index and value:      3    0.06718440
 real part, imaginary part below
    7.78004308    0.00000000    0.00000000         0.00000000    0.00000000    0.00000000
    0.00000000    7.78004308    0.00000000         0.00000000    0.00000000    0.00000000
    0.00000000    0.00000000    7.78004308         0.00000000    0.00000000    0.00000000

    """


def test_parse_eps00_frequencies():
    """ Test parsing frequencies from EPS00_GW.OUT
    """
    line = get_new_line_indices(eps_string)

    ref = {1: 0.00529953, 2: 0.02771249, 3: 0.06718440}

    assert eps_string[line[0]:line[1]].isspace(), "First line of eps_string must be a whiteline"
    assert parse_eps00_frequencies(eps_string) == ref, "Frequency grid for eps00"


def test_parse_eps00_gw():
    """ Test parsing EPS00_GW.OUT
    """
    line = get_new_line_indices(eps_string)
    assert eps_string[line[0]:line[1]].isspace(), "First line of eps_string must be a whiteline"

    ref = {
        1: {
            'frequency': 0.00529953,
            'eps00': {
                're': np.array([[8.31881773, 0., 0.], [0., 8.31881773, 0.], [0., 0., 8.31881773]]),
                'img': np.array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])
                }
            },
        2: {
            'frequency': 0.02771249,
            'eps00': {
                're': np.array([[8.22189228, 0., 0.], [0., 8.22189228, 0.], [0., 0., 8.22189228]]),
                'img': np.array([[-0., 0., 0.], [0., -0., 0.], [0., 0., -0.]])
                }
            },
        3: {
            'frequency': 0.06718440,
            'eps00': {
                're': np.array([[7.78004308, 0.0, 0.0], [0., 7.78004308, 0.], [0., 0., 7.78004308]]),
                'img': np.array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])
                }
            }
        }

    output = parse_eps00_gw(eps_string)

    assert len(output) == 3, "3 frequency points"
    assert [k for k in output[1].keys()] == ['frequency', 'eps00'], "Frequency point 1 keys "
    assert [k for k in output[2].keys()] == ['frequency', 'eps00'], "Frequency point 2 keys "
    assert [k for k in output[3].keys()] == ['frequency', 'eps00'], "Frequency point 3 keys "

    assert output[1]['frequency'] == 0.00529953, "Frequency point 1 value"
    assert output[2]['frequency'] == 0.02771249, "Frequency point 2 value"
    assert output[3]['frequency'] == 0.06718440, "Frequency point 3 value"

    assert np.allclose(output[1]['eps00']['re'], ref[1]['eps00']['re']),"Re{eps00} at frequency point 1"
    assert np.allclose(output[1]['eps00']['img'], ref[1]['eps00']['img']),"Im{eps00} at frequency point 1"

    assert np.allclose(output[2]['eps00']['re'], ref[2]['eps00']['re']),"Re{eps00} at frequency point 2"
    assert np.allclose(output[2]['eps00']['img'], ref[2]['eps00']['img']),"Im{eps00} at frequency point 2"

    assert np.allclose(output[3]['eps00']['re'], ref[3]['eps00']['re']),"Re{eps00} at frequency point 3"
    assert np.allclose(output[3]['eps00']['img'], ref[3]['eps00']['img']),"Im{eps00} at frequency point 3"
